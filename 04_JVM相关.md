### 版本号 ###
version=1.0-20201224-001

### 基本介绍 ###
总结原理


### JVM相关 ###
** JVM有什么内存结构 **
1.程序计数器
  当前线程所执行的字节码的行号指示器，用于记录当前指令的地址，线程私有
2.本地方法栈
  只服务于本地方法，线程私有
3.虚拟机栈
  存放基本数据类型，对象的引用，方法出口，线程私有
4.堆
  java内存最大的一块，所有对象实例，数组都存在堆中，GC回收的地方，线程共享
5.方法区
  存在已经加载的类信息，常量，静态变量，编译后的代码数据，线程共享
  
  
 ** JVM有内存分类 **

java堆=新生代+老年代
新生代=Eden区+Survivor区
Survivor区=S0+S1


 ** JVM为什么要分为Eden区和Survivor区，为什么要设置两个Survivor区 **
 
 1.如果没有Survivor区, Eden每进行一次Minor GC就会被送到老年代，老年代很快就会被填满。
   老年代的内存空间远大于新空间，进行一次full GC消耗的时间长
   
 2.Survivor存在的意义：减少被送到老年代的对象，减少full gc的发生，Suruvivor的筛选保证，
 只有经历过16次Minor GC还能在新生代存活的对象，才会被送到老年代
 
 3.设置2个Survivor区最大的好处是为了解决碎片化，刚刚新建的对象在Eden区中，经历一次MinorGC，Eden区存活的对象就会被移动到第一块SurvivorS0,Eden被清空
   等Eden区满了，再触发一次MinorGC,Eden区和S0中的存活对象又会被复制送入第二块Survivor S1区（复制算法）
   
 ** JVM常见的垃圾收集算法 **
1.标记清除算法
	标记清除用在新生代，首先标记所需要回收的对象，在标记完成后统一回收所有被标记的对象。
2.复制算法
	复制算法用在存活区，把不需要回收的对象全部放在s0/s1区，然后将它们统一的清理
3.标记整理算法	
    标记整理算法主要用于老年代，将需要回收的对象压缩在一起进行回收
	
	
 ** JVM一次完整的GC流程是怎样的，怎么晋升到老年代 **
 1.当Eden区空间满了，Java虚拟机会触发一次MinorGC,以收集新生代的垃圾，存活下来的对象，则会被转移到Surviror
 2.大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年代
 3.如果对象在Eden区出生，并经过一次MinorGC仍然存活，并且被survivor容纳，年龄设为1，每经过一次Minor GC,年龄加1，如果超过15，直接晋升老年代
 4.老年代无法容纳g更多的对象，MinorGC通过就会进行FullGC,Full GC清理整个内存堆，包括年轻代和老年代
 
 
 ** JVM的垃圾收集器，各自优缺点，CMS和G1 **
 CMS: 是一种以获得最短回收停顿时间为目标，使用标记清除算法，运作过程为：初始标识，并发标识，最终标识，筛选标识，会产生大量空间碎片
 G1: 标记整理算法，不会产生空间碎片
 
 区别：
 1.CMS是老年代的收集器，可以配合新生代的serial和parnew收集器一起使用
 2.G1d的收集范围为：老年代和新生代，不需要其他收集器配合使用
 
 
 ** JsTack排查堆栈信息 **
 1、top查看消耗cpu高的进程，查看其pid
top
2、根据pid根据进程查看具体线程消耗的情况
ps p 3036 -L -o pcpu,pid,tid,time,tname,cmd
3、查看占用率高的线程id
4、将获取的线程号（十进制数）转换成十六进制
printf "%x\n"  3046
5、jstack -l pid(进程号)
在打印信息中，查看nid=(刚刚获取的十六进制的值，找到对应代码，根据信息进行优化)


** JVM调优 **
Xms 设置初始堆的大小
-Xmx 设置最大堆的大小
-Xmn 设置年轻代大小，相当于同时配置-XX:NewSize和-XX:MaxNewSize为一样的值
-Xss  每个线程的堆栈大小
-XX:NewSize 设置年轻代大小(for 1.3/1.4)
-XX:MaxNewSize 年轻代最大值(for 1.3/1.4)
-XX:NewRatio 年轻代与年老代的比值(除去持久代)
-XX:SurvivorRatio Eden区与Survivor区的的比值
-XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代。
-XX:MaxTenuringThreshold设定对象在Survivor复制的最大年龄阈值，超过阈值转移到老年代


** JVM为什么是守护进程 **
【为什么垃圾回收线程需要是守护线程啦】。
守护线程拥有「自动结束自己生命周期的特性」，非守护线程却没有。如果垃圾回收线程是非守护线程，
当JVM 要退出时，由于垃圾回收线程还在运行着，导致程序无法退出，这就很尴尬。


** JAVA虚拟机为什么使用元空间替换了永久代 **
方法区和堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。
如果在HotSpot虚拟机上开发、部署，很多程序员都把方法区称作永久代。可以说方法区是规范，永久代是Hotspot针对该规范进行的实现。
在Java7及以前的版本，方法区都是永久代实现的。

对于Java8，HotSpots取消了永久代，取而代之的是元空间(Metaspace)。换句话说，就是方法区还是在的，只是实现变了，从永久代变为元空间了。
JDK8之后，方法区存在于元空间(Metaspace)。物理内存不再与堆连续，而是直接存在于本地内存中，理论上机器「内存有多大，元空间就有多大」。